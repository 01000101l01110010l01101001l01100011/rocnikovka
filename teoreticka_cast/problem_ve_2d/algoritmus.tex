\section{Algoritmus}
\label{sec:algoritmus}
Následující algoritmus je časově efektivnější, než zkoušení všech možností, ale pořád zabere \textcolor{red}{IDK} čas. 

Nechť $V$ je množina bodů v rovině a pro každé dva body $u, v \in V$ označme $d(u, v)$ jejich vzájemnou vzdálenost. Množinu hran označíme $E = \binom{V}{2}$ a váhu, neboli ohodnocení, nám určuje zobrazení $w$ dané předpisem $w(\{u, v\}) \coloneqq d(u, v)\mid \forall (u, v) \in E$. Nyní si můžeme definovat graf $G = (V, E, w)$.
Tímto je příprava hotova. Následuje hledání cyklu délky 3 s minimální váhou.

Náhodně vybereme jednu hranu $\{u, v\} \in E$ a odebereme ji z množiny hran $E$. Dále potřebujeme najít cestu s minimální váhou mezi body $u$ a  $v$. K tomuto použijeme Dijkstrův algoritmus. Ten nám vrátí cestu délky dva. Ta se bude skládat ze dvou hran: $\{u, j\}$ a $\{j, v\}$. Teď musíme zkontrolovat, zda tato cesta s hranou $\{u, v\}$ opravdu tvoří trojúhelník. Může se stát, že body $u, j, v$ leží na jedné přímce. Abychom zkontrolovali, že body neleží na jedné přímce, musíme problém rozdělit na tři případy: vertikální přímky, horizontální přímky a přímky s libovolným sklonem. Že se jedná o vertikální přímku poznáme podle toho, že $u_x = j_x = v_x$. Poté z grafu odebereme hranu $\{min(\{u_y, j_y, v_y\}), max(\{u_y, j_y, v_y\})\}$. Horizontální přímku poznáme stejným způsobem; zkontrolujeme, zda $u_y = j_y = v_y$. Pokud se tak stane, odebereme hranu $\{min(\{u_x, j_x, v_x\}), max(\{u_x, j_x, v_x\})\}$. Pokud se nejedná o vertikální ani horizontální přímku, musíme zkontrolovat, zda body leží na přímce s libovolným sklonem. K tomu využijeme podobnost trojúhelníků. Definujeme si body $a \coloneqq min(\{u_x, j_x, v_x\}), c \coloneqq max(\{u_x, j_x, v_x\})$ a bod $b$ je zbývající. Pak platí $a_x < b_x < c_x$. Z podobnosti trojúhelníků pak platí $\frac{c_y - a_y}{c_x - a_x} = \frac{b_y - a_y}{b_x - a_x}$, pokud tyto tři body jsou na přímce.  


Tyto body tvoří podgraf ve tvaru trojúhelníku $T = (V_T, E_T, w)$, kde $V_T = \{u, j, v\}$, $E_T = \{\{u,j\}, \{j,v\}, \{u,v\}\}$ a váha hran se zachová. Pokud trojúhelník (cyklus délky tři) bude mít celkovou váhu menší než ten, který jsme doposud našli, uložíme jej.
Vrátíme hranu $\{u, v\}$ do množiny hran $E$. Tento postup opakujeme dokud nevyzkoušíme všchny hrany. Výsledkem bude trojúhelník s minimálním obvodem. Na \myref{obrázku}{obr:algoritmus_graf} můžete vidět jak algoritmus funguje.

\subsection{Algoritmus v pseudokódu}
Pseudokód je popis jednotlivých kroků v algoritmu s použitím základní logiky programovacích jazyků. Následuje náš algoritmus napsaný v pseudokódu.


\begin{algorithm}[t]
    \caption{Algoritmus na hledání cyklu délky 3.}
    \label{alg:algoritmus}

    \SetKwInOut{Input}{input}
    \SetKwInOut{Output}{output}
    \SetKw{KwReturn}{return}
   
    \Input{Množina bodů $V$ v rovině, kde každý bod je reprezentován jako dvojice souřadnic $(v_x, v_y)$}
    \Output{Trojúhelník $T = (V_T, E_T, w)$}
    \BlankLine
    \For{$u \in V$}{
        \For{$v \in V$}{
        $d(u, v) \leftarrow \sqrt{(v_x-u_x)^2+(v_y-u_y)^2}$\;
        $ w(\{u, v\}) \leftarrow d(u, v)$\;
        }
    }
    $ E \leftarrow{\binom{V}{2}}$\;
    $ G \leftarrow (V, E, w)$\;
    $min_T \leftarrow \infty$\;
    \For{$\{u, v\} \in E$}{
        $E \leftarrow E \setminus \{u, v\}$\;
        $j \leftarrow dijkstra(G, u, v)$\;
        \If{$w\{u, j\} + w\{j, v\} == w\{u, v\}$}{
            $smallest$ $= min(u_x, j_x, v_x)$\;
            $biggest$ $= max(u_x, j_x, v_x)$\;
            $E \leftarrow E \cup \{u, v\}$\;
            $ E \leftarrow E \setminus \{smallest, biggest\}$\;
            \textcolor{red}{Tohle neni dobre}
        }
        \ElseIf{$p(u, j, v) < min_T$}{
            $min_T \leftarrow p(u, j, v)$\;
            $V_T \leftarrow \{u, j, v\}$\;
            $E_T \leftarrow \{\{u,j\}, \{j,v\}, \{u,v\}\}$\;
            $T \leftarrow (V_T, E_T, w)$\;
            $E \leftarrow E \cup \{u, v\}$\;
        }
        \Else{
            $ E \leftarrow E \cup \{u, v\}$\;
        }
    }
    \KwReturn{$T$}\;
   \end{algorithm}
   \begin{figure}[H]
    \centering
    \begin{tikzpicture}[node distance=2cm]
        \node[draw, circle, fill, inner sep=1.5pt] (A) at (-6,4) {};
        \node[left] at (A) {$a$};
        \node[draw, circle, fill, inner sep=1.5pt] (B) at (-4,5) {};
        \node[below] at (B.south) {$b$};
        \node[draw, circle, fill, inner sep=1.5pt] (C) at (-5,0) {};
        \node[below] at (C.south) {$c$};
        \node[draw, circle, fill, inner sep=1.5pt] (D) at (3,0) {};
        \node[below] at (D.south) {$d$};
        \node[draw, circle, fill, inner sep=1.5pt] (E) at (6,4.75) {};
        \node[below] at (E.south) {$e$};
        \node[draw, circle, fill, inner sep=1.5pt] (G) at (0,3.5) {};
        \node[below] at (G.south) {$g$};
        
        % Additional edges
        \draw[lightgray, line width=0.5pt] (A) -- (E);
        \draw[lightgray, line width=0.5pt] (A) -- (G);
        \draw[lightgray, line width=0.5pt] (B) -- (C);
        \draw[lightgray, line width=0.5pt] (B) -- (E);
        \draw[lightgray, line width=0.5pt] (B) -- (G);
        \draw[lightgray, line width=0.5pt] (C) -- (E);
        \draw[lightgray, line width=0.5pt] (E) -- (G);
        \draw[lightgray, line width=0.5pt] (A) -- (B);
        \draw[lightgray, line width=0.5pt] (B) -- (D);
        \draw[lightgray, line width=0.5pt] (A) -- (D);
        \draw[lightgray, line width=0.5pt] (A) -- (C);
        \draw[lightgray, line width=0.5pt] (D) -- (E);
        \draw[mygreen, line width=1.5pt] (C) -- node[above] {2}(G);
        \draw[mygreen, line width=1.5pt] (D) -- node[above] {1}(G);
        \draw[myred, line width=1.5pt] (C) -- node[above] {1} (D); 
    \end{tikzpicture}
    \caption{Příklad případu, kdy algoritmus vybral hranu $\{c, d\}$, odebral ji z množiny hran, a pomocí Dijkstrova algoritmu našel nejkratší cestu z bodu $c$ do bodu $d$. (Pro čitelnost nejsou zobrazeny váhy ostatních hran. Předpokládejme, že jsou vyšší, než 3.)}
    \label{obr:algoritmus_graf}
\end{figure}